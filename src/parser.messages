mod_: ASSERT STRING COMMA WHILE
##
## Ends in an error in state: 176.
##
## assert_message -> COMMA . test [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: ASSERT STRING SUBEQ
##
## Ends in an error in state: 175.
##
## small_stmt -> ASSERT test . assert_message [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## ASSERT test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: ASSERT WHILE
##
## Ends in an error in state: 174.
##
## small_stmt -> ASSERT . test assert_message [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## ASSERT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS IDENTIFIER COLON WHILE
##
## Ends in an error in state: 267.
##
## compound_stmt -> CLASS IDENTIFIER class_parameters COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## CLASS IDENTIFIER class_parameters COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS IDENTIFIER LPAREN IDENTIFIER COLON
##
## Ends in an error in state: 264.
##
## class_parameters -> LPAREN parameters . RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production parameter -> IDENTIFIER 
## In state 108, spurious reduction of production separated_nonempty_list(COMMA,parameter) -> parameter 
## In state 104, spurious reduction of production loption(separated_nonempty_list(COMMA,parameter)) -> separated_nonempty_list(COMMA,parameter) 
## In state 111, spurious reduction of production parameters -> loption(separated_nonempty_list(COMMA,parameter)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS IDENTIFIER LPAREN RPAREN CLASS
##
## Ends in an error in state: 266.
##
## compound_stmt -> CLASS IDENTIFIER class_parameters . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## CLASS IDENTIFIER class_parameters
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS IDENTIFIER LPAREN WHILE
##
## Ends in an error in state: 263.
##
## class_parameters -> LPAREN . parameters RPAREN [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS IDENTIFIER WHILE
##
## Ends in an error in state: 262.
##
## compound_stmt -> CLASS IDENTIFIER . class_parameters COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## CLASS IDENTIFIER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: CLASS WHILE
##
## Ends in an error in state: 261.
##
## compound_stmt -> CLASS . IDENTIFIER class_parameters COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## CLASS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF IDENTIFIER LPAREN IDENTIFIER COLON
##
## Ends in an error in state: 257.
##
## compound_stmt -> DEF IDENTIFIER LPAREN parameters . RPAREN COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF IDENTIFIER LPAREN parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production parameter -> IDENTIFIER 
## In state 108, spurious reduction of production separated_nonempty_list(COMMA,parameter) -> parameter 
## In state 104, spurious reduction of production loption(separated_nonempty_list(COMMA,parameter)) -> separated_nonempty_list(COMMA,parameter) 
## In state 111, spurious reduction of production parameters -> loption(separated_nonempty_list(COMMA,parameter)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF IDENTIFIER LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 259.
##
## compound_stmt -> DEF IDENTIFIER LPAREN parameters RPAREN COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF IDENTIFIER LPAREN parameters RPAREN COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF IDENTIFIER LPAREN RPAREN WHILE
##
## Ends in an error in state: 258.
##
## compound_stmt -> DEF IDENTIFIER LPAREN parameters RPAREN . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF IDENTIFIER LPAREN parameters RPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF IDENTIFIER LPAREN WHILE
##
## Ends in an error in state: 256.
##
## compound_stmt -> DEF IDENTIFIER LPAREN . parameters RPAREN COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF IDENTIFIER LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF IDENTIFIER WHILE
##
## Ends in an error in state: 255.
##
## compound_stmt -> DEF IDENTIFIER . LPAREN parameters RPAREN COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF IDENTIFIER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DEF WHILE
##
## Ends in an error in state: 254.
##
## compound_stmt -> DEF . IDENTIFIER LPAREN parameters RPAREN COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## DEF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: DELETE WHILE
##
## Ends in an error in state: 170.
##
## small_stmt -> DELETE . testlist [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## DELETE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING COMMA STRING COMMA WHILE
##
## Ends in an error in state: 143.
##
## exprlist_or_empty -> expr COMMA . exprlist_or_empty [ IN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING COMMA STRING SUBEQ
##
## Ends in an error in state: 142.
##
## exprlist_or_empty -> expr . [ IN ]
## exprlist_or_empty -> expr . COMMA exprlist_or_empty [ IN ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING COMMA WHILE
##
## Ends in an error in state: 140.
##
## exprlist -> expr COMMA . exprlist_or_empty [ IN ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING IN STRING COLON STRING NEWLINE SUBEQ
##
## Ends in an error in state: 252.
##
## compound_stmt -> FOR exprlist IN testlist COLON suite . orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN testlist COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING IN STRING COLON WHILE
##
## Ends in an error in state: 251.
##
## compound_stmt -> FOR exprlist IN testlist COLON . suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN testlist COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING IN STRING SUBEQ
##
## Ends in an error in state: 250.
##
## compound_stmt -> FOR exprlist IN testlist . COLON suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING IN WHILE
##
## Ends in an error in state: 249.
##
## compound_stmt -> FOR exprlist IN . testlist COLON suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR STRING SUBEQ
##
## Ends in an error in state: 139.
##
## exprlist -> expr . [ IN ]
## exprlist -> expr . COMMA exprlist_or_empty [ IN ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: FOR WHILE
##
## Ends in an error in state: 247.
##
## compound_stmt -> FOR . exprlist IN testlist COLON suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON STRING NEWLINE ELIF STRING COLON BOOL NEWLINE SUBEQ
##
## Ends in an error in state: 245.
##
## list(elif) -> elif . list(elif) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## elif
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON STRING NEWLINE ELIF STRING COLON WHILE
##
## Ends in an error in state: 238.
##
## elif -> ELIF test COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELIF test COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON STRING NEWLINE ELIF STRING SUBEQ
##
## Ends in an error in state: 237.
##
## elif -> ELIF test . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELIF test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON STRING NEWLINE ELIF WHILE
##
## Ends in an error in state: 236.
##
## elif -> ELIF . test COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELIF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON STRING NEWLINE SUBEQ
##
## Ends in an error in state: 235.
##
## compound_stmt -> IF test COLON suite . list(elif) orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## IF test COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING COLON WHILE
##
## Ends in an error in state: 234.
##
## compound_stmt -> IF test COLON . suite list(elif) orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## IF test COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF STRING SUBEQ
##
## Ends in an error in state: 233.
##
## compound_stmt -> IF test . COLON suite list(elif) orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## IF test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: IF WHILE
##
## Ends in an error in state: 232.
##
## compound_stmt -> IF . test COLON suite list(elif) orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA COLON WHILE
##
## Ends in an error in state: 106.
##
## test -> LAMBDA parameters COLON . test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## LAMBDA parameters COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA IDENTIFIER COMMA WHILE
##
## Ends in an error in state: 109.
##
## separated_nonempty_list(COMMA,parameter) -> parameter COMMA . separated_nonempty_list(COMMA,parameter) [ RPAREN COLON ]
##
## The known suffix of the stack is as follows:
## parameter COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA IDENTIFIER EQUAL WHILE
##
## Ends in an error in state: 17.
##
## parameter -> IDENTIFIER EQUAL . expr [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA IDENTIFIER RPAREN
##
## Ends in an error in state: 105.
##
## test -> LAMBDA parameters . COLON test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## LAMBDA parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production parameter -> IDENTIFIER 
## In state 108, spurious reduction of production separated_nonempty_list(COMMA,parameter) -> parameter 
## In state 104, spurious reduction of production loption(separated_nonempty_list(COMMA,parameter)) -> separated_nonempty_list(COMMA,parameter) 
## In state 111, spurious reduction of production parameters -> loption(separated_nonempty_list(COMMA,parameter)) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA IDENTIFIER WHILE
##
## Ends in an error in state: 16.
##
## parameter -> IDENTIFIER . [ RPAREN COMMA COLON ]
## parameter -> IDENTIFIER . EQUAL expr [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA OPMUL WHILE
##
## Ends in an error in state: 14.
##
## parameter -> OPMUL . IDENTIFIER [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## OPMUL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA OPPOWER IDENTIFIER WHILE
##
## Ends in an error in state: 108.
##
## separated_nonempty_list(COMMA,parameter) -> parameter . [ RPAREN COLON ]
## separated_nonempty_list(COMMA,parameter) -> parameter . COMMA separated_nonempty_list(COMMA,parameter) [ RPAREN COLON ]
##
## The known suffix of the stack is as follows:
## parameter
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA OPPOWER WHILE
##
## Ends in an error in state: 12.
##
## parameter -> OPPOWER . IDENTIFIER [ RPAREN COMMA COLON ]
##
## The known suffix of the stack is as follows:
## OPPOWER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LAMBDA WHILE
##
## Ends in an error in state: 11.
##
## test -> LAMBDA . parameters COLON test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## LAMBDA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACE STRING COLON BOOL COMMA WHILE
##
## Ends in an error in state: 119.
##
## separated_nonempty_list(COMMA,key_value) -> key_value COMMA . separated_nonempty_list(COMMA,key_value) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## key_value COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACE STRING COLON BOOL SUBEQ
##
## Ends in an error in state: 118.
##
## separated_nonempty_list(COMMA,key_value) -> key_value . [ RBRACE ]
## separated_nonempty_list(COMMA,key_value) -> key_value . COMMA separated_nonempty_list(COMMA,key_value) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## key_value
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 114, spurious reduction of production key_value -> test COLON test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACE STRING COLON WHILE
##
## Ends in an error in state: 113.
##
## key_value -> test COLON . test [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## test COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACE STRING SUBEQ
##
## Ends in an error in state: 112.
##
## key_value -> test . COLON test [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACE WHILE
##
## Ends in an error in state: 10.
##
## atom -> LBRACE . loption(separated_nonempty_list(COMMA,key_value)) RBRACE [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING COMMA STRING SUBEQ
##
## Ends in an error in state: 149.
##
## separated_nonempty_list(COMMA,expr) -> expr . [ RBRACK ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING COMMA WHILE
##
## Ends in an error in state: 147.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING FOR STRING IN STRING SUBEQ
##
## Ends in an error in state: 136.
##
## fors -> FOR exprlist IN or_test . ifs fors [ RBRACK ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN or_test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING FOR STRING IN WHILE
##
## Ends in an error in state: 135.
##
## fors -> FOR exprlist IN . or_test ifs fors [ RBRACK ]
##
## The known suffix of the stack is as follows:
## FOR exprlist IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING FOR WHILE
##
## Ends in an error in state: 133.
##
## fors -> FOR . exprlist IN or_test ifs fors [ RBRACK ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING IF STRING SUBEQ
##
## Ends in an error in state: 130.
##
## ifs -> IF or_test . ifs [ RBRACK FOR ]
##
## The known suffix of the stack is as follows:
## IF or_test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING IF WHILE
##
## Ends in an error in state: 129.
##
## ifs -> IF . or_test ifs [ RBRACK FOR ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN STRING SUBEQ
##
## Ends in an error in state: 128.
##
## atom -> LBRACK expr FOR exprlist IN or_test . ifs fors RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LBRACK expr FOR exprlist IN or_test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR STRING IN WHILE
##
## Ends in an error in state: 127.
##
## atom -> LBRACK expr FOR exprlist IN . or_test ifs fors RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LBRACK expr FOR exprlist IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING FOR WHILE
##
## Ends in an error in state: 125.
##
## atom -> LBRACK expr FOR . exprlist IN or_test ifs fors RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LBRACK expr FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK STRING SUBEQ
##
## Ends in an error in state: 124.
##
## atom -> LBRACK expr . FOR exprlist IN or_test ifs fors RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
## separated_nonempty_list(COMMA,expr) -> expr . [ RBRACK ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## LBRACK expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LBRACK WHILE
##
## Ends in an error in state: 9.
##
## atom -> LBRACK . loption(separated_nonempty_list(COMMA,expr)) RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
## atom -> LBRACK . expr FOR exprlist IN or_test ifs fors RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LPAREN STRING SUBEQ
##
## Ends in an error in state: 151.
##
## atom -> LPAREN testlist . RPAREN [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LPAREN testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: LPAREN WHILE
##
## Ends in an error in state: 7.
##
## atom -> LPAREN . testlist RPAREN [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: NEWLINE SUBEQ
##
## Ends in an error in state: 279.
##
## list(newline_or_stmt) -> newline_or_stmt . list(newline_or_stmt) [ ENDMARKER ]
##
## The known suffix of the stack is as follows:
## newline_or_stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: OPADD WHILE
##
## Ends in an error in state: 5.
##
## factor -> OPADD . factor [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## OPADD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: OPINVERT WHILE
##
## Ends in an error in state: 4.
##
## factor -> OPINVERT . factor [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## OPINVERT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: OPNOT WHILE
##
## Ends in an error in state: 8.
##
## not_test -> OPNOT . not_test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPAND NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## OPNOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: OPSUB WHILE
##
## Ends in an error in state: 3.
##
## factor -> OPSUB . factor [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## OPSUB
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: PASS WHILE
##
## Ends in an error in state: 201.
##
## simple_stmt -> small_stmt . NEWLINE [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## simple_stmt -> small_stmt . SEMICOLON simple_stmt_or_empty [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## small_stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: RAISE FROM WHILE
##
## Ends in an error in state: 163.
##
## flow_stmt -> RAISE option(test) FROM . test [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## RAISE option(test) FROM
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: RAISE STRING EQUAL
##
## Ends in an error in state: 162.
##
## flow_stmt -> RAISE option(test) . [ SEMICOLON NEWLINE ]
## flow_stmt -> RAISE option(test) . FROM test [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## RAISE option(test)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 161, spurious reduction of production option(test) -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: RAISE WHILE
##
## Ends in an error in state: 160.
##
## flow_stmt -> RAISE . option(test) [ SEMICOLON NEWLINE ]
## flow_stmt -> RAISE . option(test) FROM test [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## RAISE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: RETURN WHILE
##
## Ends in an error in state: 158.
##
## flow_stmt -> RETURN . [ SEMICOLON NEWLINE ]
## flow_stmt -> RETURN . testlist [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## RETURN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING AS
##
## Ends in an error in state: 62.
##
## comparison -> expr . [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPAND NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
## comparison -> expr . comp_op comparison [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPAND NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING COMMA STRING COMMA WHILE
##
## Ends in an error in state: 97.
##
## testlist_or_empty -> test COMMA . testlist_or_empty [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## test COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING COMMA STRING RBRACE
##
## Ends in an error in state: 96.
##
## testlist_or_empty -> test . [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
## testlist_or_empty -> test . COMMA testlist_or_empty [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING COMMA WHILE
##
## Ends in an error in state: 94.
##
## testlist -> test COMMA . testlist_or_empty [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## test COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING DOT WHILE
##
## Ends in an error in state: 99.
##
## atom_expr -> atom_expr DOT . IDENTIFIER [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING EQUAL STRING EQUAL STRING EQUAL WHILE
##
## Ends in an error in state: 187.
##
## separated_nonempty_list(EQUAL,testlist) -> testlist EQUAL . separated_nonempty_list(EQUAL,testlist) [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING EQUAL STRING EQUAL STRING SUBEQ
##
## Ends in an error in state: 186.
##
## separated_nonempty_list(EQUAL,testlist) -> testlist . [ SEMICOLON NEWLINE ]
## separated_nonempty_list(EQUAL,testlist) -> testlist . EQUAL separated_nonempty_list(EQUAL,testlist) [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING EQUAL STRING EQUAL WHILE
##
## Ends in an error in state: 185.
##
## assign_right -> EQUAL . loption(separated_nonempty_list(EQUAL,testlist)) [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING EQUAL STRING SUBEQ
##
## Ends in an error in state: 184.
##
## small_stmt -> testlist EQUAL testlist . assign_right [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist EQUAL testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING EQUAL WHILE
##
## Ends in an error in state: 183.
##
## small_stmt -> testlist EQUAL . testlist assign_right [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING FOR
##
## Ends in an error in state: 54.
##
## test -> or_test . [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
## test -> or_test . IF or_test ELSE test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## or_test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING IF STRING ELSE WHILE
##
## Ends in an error in state: 57.
##
## test -> or_test IF or_test ELSE . test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## or_test IF or_test ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING IF STRING SUBEQ
##
## Ends in an error in state: 56.
##
## test -> or_test IF or_test . ELSE test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## or_test IF or_test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING IF WHILE
##
## Ends in an error in state: 55.
##
## test -> or_test IF . or_test ELSE test [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ FROM EQUAL EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## or_test IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LBRACK STRING SUBEQ
##
## Ends in an error in state: 91.
##
## atom_expr -> atom_expr LBRACK testlist . RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr LBRACK testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LBRACK WHILE
##
## Ends in an error in state: 90.
##
## atom_expr -> atom_expr LBRACK . testlist RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LPAREN IDENTIFIER EQUAL WHILE
##
## Ends in an error in state: 42.
##
## argument -> IDENTIFIER EQUAL . test [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LPAREN IDENTIFIER WHILE
##
## Ends in an error in state: 41.
##
## argument -> IDENTIFIER . EQUAL test [ RPAREN COMMA ]
## atom -> IDENTIFIER . [ RPAREN OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD LPAREN LBRACK IN IF DOT COMMA ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LPAREN STRING COMMA WHILE
##
## Ends in an error in state: 88.
##
## separated_nonempty_list(COMMA,argument) -> argument COMMA . separated_nonempty_list(COMMA,argument) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## argument COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LPAREN STRING SUBEQ
##
## Ends in an error in state: 87.
##
## separated_nonempty_list(COMMA,argument) -> argument . [ RPAREN ]
## separated_nonempty_list(COMMA,argument) -> argument . COMMA separated_nonempty_list(COMMA,argument) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## argument
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 83, spurious reduction of production argument -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING LPAREN WHILE
##
## Ends in an error in state: 40.
##
## atom_expr -> atom_expr LPAREN . loption(separated_nonempty_list(COMMA,argument)) RPAREN [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPAND WHILE
##
## Ends in an error in state: 60.
##
## separated_nonempty_list(OPAND,not_test) -> not_test OPAND . separated_nonempty_list(OPAND,not_test) [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## not_test OPAND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPBAND WHILE
##
## Ends in an error in state: 45.
##
## and_expr -> shift_expr OPBAND . and_expr [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPNOT OPNEQ OPLTEQ OPLT OPIS OPGTEQ OPGT OPEQ OPBXOR OPBOR OPAND NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## shift_expr OPBAND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPBOR WHILE
##
## Ends in an error in state: 23.
##
## expr -> xor_expr OPBOR . expr [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPNOT OPNEQ OPLTEQ OPLT OPIS OPGTEQ OPGT OPEQ OPAND NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## xor_expr OPBOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPBXOR WHILE
##
## Ends in an error in state: 77.
##
## xor_expr -> and_expr OPBXOR . xor_expr [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPNOT OPNEQ OPLTEQ OPLT OPIS OPGTEQ OPGT OPEQ OPBOR OPAND NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## and_expr OPBXOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPIS WHILE
##
## Ends in an error in state: 68.
##
## comp_op -> OPIS . [ STRING OPSUB OPINVERT OPADD NONE LPAREN LBRACK LBRACE INTEGER IDENTIFIER FLOAT BOOL ]
## comp_op -> OPIS . OPNOT [ STRING OPSUB OPINVERT OPADD NONE LPAREN LBRACK LBRACE INTEGER IDENTIFIER FLOAT BOOL ]
##
## The known suffix of the stack is as follows:
## OPIS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPMUL WHILE
##
## Ends in an error in state: 34.
##
## term -> factor opfactor . term [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## factor opfactor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPNEQ WHILE
##
## Ends in an error in state: 74.
##
## comparison -> expr comp_op . comparison [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPAND NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## expr comp_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPNOT WHILE
##
## Ends in an error in state: 63.
##
## comp_op -> OPNOT . IN [ STRING OPSUB OPINVERT OPADD NONE LPAREN LBRACK LBRACE INTEGER IDENTIFIER FLOAT BOOL ]
##
## The known suffix of the stack is as follows:
## OPNOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPOR WHILE
##
## Ends in an error in state: 81.
##
## separated_nonempty_list(OPOR,and_test) -> and_test OPOR . separated_nonempty_list(OPOR,and_test) [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE NEWLINE MULEQ MODEQ IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## and_test OPOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPPOWER WHILE
##
## Ends in an error in state: 37.
##
## power -> atom_expr OPPOWER . factor [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr OPPOWER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPRSHIFT WHILE
##
## Ends in an error in state: 49.
##
## shift_expr -> arith_expr opshift . shift_expr [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPOR OPNOT OPNEQ OPLTEQ OPLT OPIS OPGTEQ OPGT OPEQ OPBXOR OPBOR OPBAND OPAND NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## arith_expr opshift
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING OPSUB WHILE
##
## Ends in an error in state: 27.
##
## arith_expr -> term oparith . arith_expr [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPRSHIFT OPOR OPNOT OPNEQ OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPBXOR OPBOR OPBAND OPAND NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## term oparith
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING RBRACE
##
## Ends in an error in state: 93.
##
## testlist -> test . [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
## testlist -> test . COMMA testlist_or_empty [ SUBEQ SEMICOLON RPAREN RBRACK NEWLINE MULEQ MODEQ EQUAL EDIVEQ DIVEQ COLON ADDEQ ]
##
## The known suffix of the stack is as follows:
## test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING RPAREN
##
## Ends in an error in state: 179.
##
## small_stmt -> testlist . [ SEMICOLON NEWLINE ]
## small_stmt -> testlist . EQUAL testlist assign_right [ SEMICOLON NEWLINE ]
## small_stmt -> testlist . augassign testlist [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
## In state 93, spurious reduction of production testlist -> test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING SEMICOLON PASS WHILE
##
## Ends in an error in state: 204.
##
## simple_stmt_or_empty -> small_stmt . NEWLINE [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## simple_stmt_or_empty -> small_stmt . SEMICOLON simple_stmt_or_empty [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## small_stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING SEMICOLON STRING SEMICOLON WHILE
##
## Ends in an error in state: 205.
##
## simple_stmt_or_empty -> small_stmt SEMICOLON . simple_stmt_or_empty [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## small_stmt SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING SEMICOLON WHILE
##
## Ends in an error in state: 202.
##
## simple_stmt -> small_stmt SEMICOLON . simple_stmt_or_empty [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## small_stmt SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING SUBEQ WHILE
##
## Ends in an error in state: 195.
##
## small_stmt -> testlist augassign . testlist [ SEMICOLON NEWLINE ]
##
## The known suffix of the stack is as follows:
## testlist augassign
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: STRING WHILE
##
## Ends in an error in state: 36.
##
## atom_expr -> atom_expr . LPAREN loption(separated_nonempty_list(COMMA,argument)) RPAREN [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
## atom_expr -> atom_expr . DOT IDENTIFIER [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
## atom_expr -> atom_expr . LBRACK testlist RBRACK [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPPOWER OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ LPAREN LBRACK IN IF FROM FOR EQUAL ELSE EDIVEQ DOT DIVEQ COMMA COLON AS ADDEQ ]
## power -> atom_expr . [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
## power -> atom_expr . OPPOWER factor [ SUBEQ SEMICOLON RPAREN RBRACK RBRACE OPSUB OPRSHIFT OPOR OPNOT OPNEQ OPMUL OPMOD OPLTEQ OPLT OPLSHIFT OPIS OPGTEQ OPGT OPEQ OPEDIV OPDIV OPBXOR OPBOR OPBAND OPAND OPADD NEWLINE MULEQ MODEQ IN IF FROM FOR EQUAL ELSE EDIVEQ DIVEQ COMMA COLON AS ADDEQ ]
##
## The known suffix of the stack is as follows:
## atom_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: SUBEQ
##
## Ends in an error in state: 0.
##
## mod_' -> . mod_ [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON NEWLINE INDENT STRING NEWLINE SUBEQ
##
## Ends in an error in state: 269.
##
## nonempty_list(stmt) -> stmt . [ DEDENT ]
## nonempty_list(stmt) -> stmt . nonempty_list(stmt) [ DEDENT ]
##
## The known suffix of the stack is as follows:
## stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON NEWLINE INDENT SUBEQ
##
## Ends in an error in state: 167.
##
## suite -> NEWLINE INDENT . nonempty_list(stmt) DEDENT [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## NEWLINE INDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON NEWLINE WHILE
##
## Ends in an error in state: 166.
##
## suite -> NEWLINE . INDENT nonempty_list(stmt) DEDENT [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE ELIF DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## NEWLINE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT COLON BOOL NEWLINE ELSE COLON BOOL NEWLINE AS
##
## Ends in an error in state: 229.
##
## compound_stmt -> TRY COLON suite nonempty_list(try_except) try_orelse . option(try_finally) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY COLON suite nonempty_list(try_except) try_orelse
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT COLON BOOL NEWLINE ELSE COLON WHILE
##
## Ends in an error in state: 227.
##
## try_orelse -> ELSE COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELSE COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT COLON BOOL NEWLINE ELSE WHILE
##
## Ends in an error in state: 226.
##
## try_orelse -> ELSE . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT COLON BOOL NEWLINE SUBEQ
##
## Ends in an error in state: 223.
##
## nonempty_list(try_except) -> try_except . [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## nonempty_list(try_except) -> try_except . nonempty_list(try_except) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## try_except
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT COLON WHILE
##
## Ends in an error in state: 213.
##
## try_except -> EXCEPT COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT STRING AS IDENTIFIER COLON WHILE
##
## Ends in an error in state: 220.
##
## try_except -> EXCEPT expr AS IDENTIFIER COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS IDENTIFIER COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT STRING AS IDENTIFIER WHILE
##
## Ends in an error in state: 219.
##
## try_except -> EXCEPT expr AS IDENTIFIER . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS IDENTIFIER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT STRING AS WHILE
##
## Ends in an error in state: 218.
##
## try_except -> EXCEPT expr AS . IDENTIFIER COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT STRING COLON WHILE
##
## Ends in an error in state: 216.
##
## try_except -> EXCEPT expr COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT STRING SUBEQ
##
## Ends in an error in state: 215.
##
## try_except -> EXCEPT expr . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## try_except -> EXCEPT expr . AS IDENTIFIER COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE EXCEPT WHILE
##
## Ends in an error in state: 212.
##
## try_except -> EXCEPT . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## try_except -> EXCEPT . expr COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## try_except -> EXCEPT . expr AS IDENTIFIER COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT FINALLY EXCEPT ENDMARKER ELSE DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## EXCEPT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE FINALLY COLON WHILE
##
## Ends in an error in state: 199.
##
## try_finally -> FINALLY COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FINALLY COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE FINALLY WHILE
##
## Ends in an error in state: 198.
##
## try_finally -> FINALLY . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## FINALLY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON STRING NEWLINE WHILE
##
## Ends in an error in state: 197.
##
## compound_stmt -> TRY COLON suite . try_finally [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## compound_stmt -> TRY COLON suite . nonempty_list(try_except) try_orelse option(try_finally) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY COLON WHILE
##
## Ends in an error in state: 169.
##
## compound_stmt -> TRY COLON . suite try_finally [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## compound_stmt -> TRY COLON . suite nonempty_list(try_except) try_orelse option(try_finally) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: TRY WHILE
##
## Ends in an error in state: 168.
##
## compound_stmt -> TRY . COLON suite try_finally [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
## compound_stmt -> TRY . COLON suite nonempty_list(try_except) try_orelse option(try_finally) [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## TRY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE STRING COLON STRING NEWLINE ELSE COLON WHILE
##
## Ends in an error in state: 242.
##
## orelse -> ELSE COLON . suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELSE COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE STRING COLON STRING NEWLINE ELSE WHILE
##
## Ends in an error in state: 241.
##
## orelse -> ELSE . COLON suite [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE STRING COLON STRING NEWLINE SUBEQ
##
## Ends in an error in state: 275.
##
## compound_stmt -> WHILE test COLON suite . orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE test COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE STRING COLON WHILE
##
## Ends in an error in state: 157.
##
## compound_stmt -> WHILE test COLON . suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE test COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE STRING SUBEQ
##
## Ends in an error in state: 156.
##
## compound_stmt -> WHILE test . COLON suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE test
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 36, spurious reduction of production power -> atom_expr 
## In state 28, spurious reduction of production factor -> power 
## In state 29, spurious reduction of production term -> factor 
## In state 24, spurious reduction of production arith_expr -> term 
## In state 46, spurious reduction of production shift_expr -> arith_expr 
## In state 44, spurious reduction of production and_expr -> shift_expr 
## In state 76, spurious reduction of production xor_expr -> and_expr 
## In state 22, spurious reduction of production expr -> xor_expr 
## In state 62, spurious reduction of production comparison -> expr 
## In state 79, spurious reduction of production not_test -> comparison 
## In state 59, spurious reduction of production separated_nonempty_list(OPAND,not_test) -> not_test 
## In state 53, spurious reduction of production and_test -> separated_nonempty_list(OPAND,not_test) 
## In state 80, spurious reduction of production separated_nonempty_list(OPOR,and_test) -> and_test 
## In state 52, spurious reduction of production or_test -> separated_nonempty_list(OPOR,and_test) 
## In state 54, spurious reduction of production test -> or_test 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

mod_: WHILE WHILE
##
## Ends in an error in state: 1.
##
## compound_stmt -> WHILE . test COLON suite orelse [ WHILE TRY STRING RETURN RAISE PASS OPSUB OPNOT OPINVERT OPADD NONE NEWLINE LPAREN LBRACK LBRACE LAMBDA INTEGER IF IDENTIFIER FOR FLOAT ENDMARKER DELETE DEF DEDENT CONTINUE CLASS BREAK BOOL ASSERT ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

